// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlc

import (
	"context"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (handle,
                   username,
                   email,
                   email_opt_in,
                   timezone,
                   is_active,
                   is_admin,
                   is_gm,
                   is_guest,
                   is_player,
                   is_service,
                   is_user,
                   created_at,
                   updated_at)
VALUES (?1,
        ?2,
        ?3,
        ?4,
        ?5,
        ?6,
        ?7,
        ?8,
        ?9,
        ?10,
        ?11,
        ?12,
        ?13,
        ?14)
ON CONFLICT (user_id) DO UPDATE
    SET handle       = excluded.handle,
        username     = excluded.username,
        email        = excluded.email,
        email_opt_in = excluded.email_opt_in,
        timezone     = excluded.timezone,
        is_active    = excluded.is_active,
        is_admin     = excluded.is_admin,
        is_gm        = excluded.is_gm,
        is_guest     = excluded.is_guest,
        is_player    = excluded.is_player,
        is_service   = excluded.is_service,
        is_user      = excluded.is_user,
        updated_at   = excluded.updated_at
RETURNING user_id
`

type CreateUserParams struct {
	Handle     string
	Username   string
	Email      string
	EmailOptIn bool
	Timezone   string
	IsActive   bool
	IsAdmin    bool
	IsGm       bool
	IsGuest    bool
	IsPlayer   bool
	IsService  bool
	IsUser     bool
	CreatedAt  int64
	UpdatedAt  int64
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Handle,
		arg.Username,
		arg.Email,
		arg.EmailOptIn,
		arg.Timezone,
		arg.IsActive,
		arg.IsAdmin,
		arg.IsGm,
		arg.IsGuest,
		arg.IsPlayer,
		arg.IsService,
		arg.IsUser,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const readUserByEmail = `-- name: ReadUserByEmail :one
SELECT user_id,
       handle,
       username,
       email,
       email_opt_in,
       timezone,
       is_active,
       is_admin,
       is_gm,
       is_guest,
       is_player,
       is_service,
       is_sysop,
       is_user,
       created_at,
       updated_at
FROM users
WHERE email = ?1
`

type ReadUserByEmailRow struct {
	UserID     int64
	Handle     string
	Username   string
	Email      string
	EmailOptIn bool
	Timezone   string
	IsActive   bool
	IsAdmin    bool
	IsGm       bool
	IsGuest    bool
	IsPlayer   bool
	IsService  bool
	IsSysop    bool
	IsUser     bool
	CreatedAt  int64
	UpdatedAt  int64
}

func (q *Queries) ReadUserByEmail(ctx context.Context, email string) (ReadUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, readUserByEmail, email)
	var i ReadUserByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.Handle,
		&i.Username,
		&i.Email,
		&i.EmailOptIn,
		&i.Timezone,
		&i.IsActive,
		&i.IsAdmin,
		&i.IsGm,
		&i.IsGuest,
		&i.IsPlayer,
		&i.IsService,
		&i.IsSysop,
		&i.IsUser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const readUserByHandle = `-- name: ReadUserByHandle :one
SELECT user_id,
       handle,
       username,
       email,
       email_opt_in,
       timezone,
       is_active,
       is_admin,
       is_gm,
       is_guest,
       is_player,
       is_service,
       is_sysop,
       is_user,
       created_at,
       updated_at
FROM users
WHERE handle = ?1
`

type ReadUserByHandleRow struct {
	UserID     int64
	Handle     string
	Username   string
	Email      string
	EmailOptIn bool
	Timezone   string
	IsActive   bool
	IsAdmin    bool
	IsGm       bool
	IsGuest    bool
	IsPlayer   bool
	IsService  bool
	IsSysop    bool
	IsUser     bool
	CreatedAt  int64
	UpdatedAt  int64
}

func (q *Queries) ReadUserByHandle(ctx context.Context, handle string) (ReadUserByHandleRow, error) {
	row := q.db.QueryRowContext(ctx, readUserByHandle, handle)
	var i ReadUserByHandleRow
	err := row.Scan(
		&i.UserID,
		&i.Handle,
		&i.Username,
		&i.Email,
		&i.EmailOptIn,
		&i.Timezone,
		&i.IsActive,
		&i.IsAdmin,
		&i.IsGm,
		&i.IsGuest,
		&i.IsPlayer,
		&i.IsService,
		&i.IsSysop,
		&i.IsUser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const readUserByUserId = `-- name: ReadUserByUserId :one
SELECT user_id,
       handle,
       username,
       email,
       email_opt_in,
       timezone,
       is_active,
       is_admin,
       is_gm,
       is_guest,
       is_player,
       is_service,
       is_sysop,
       is_user,
       created_at,
       updated_at
FROM users
WHERE user_id = ?1
`

type ReadUserByUserIdRow struct {
	UserID     int64
	Handle     string
	Username   string
	Email      string
	EmailOptIn bool
	Timezone   string
	IsActive   bool
	IsAdmin    bool
	IsGm       bool
	IsGuest    bool
	IsPlayer   bool
	IsService  bool
	IsSysop    bool
	IsUser     bool
	CreatedAt  int64
	UpdatedAt  int64
}

func (q *Queries) ReadUserByUserId(ctx context.Context, userID int64) (ReadUserByUserIdRow, error) {
	row := q.db.QueryRowContext(ctx, readUserByUserId, userID)
	var i ReadUserByUserIdRow
	err := row.Scan(
		&i.UserID,
		&i.Handle,
		&i.Username,
		&i.Email,
		&i.EmailOptIn,
		&i.Timezone,
		&i.IsActive,
		&i.IsAdmin,
		&i.IsGm,
		&i.IsGuest,
		&i.IsPlayer,
		&i.IsService,
		&i.IsSysop,
		&i.IsUser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const readUserRoles = `-- name: ReadUserRoles :one
SELECT is_active,
       is_admin,
       is_gm,
       is_guest,
       is_player,
       is_service,
       is_sysop,
       is_user
FROM users
WHERE user_id = ?1
`

type ReadUserRolesRow struct {
	IsActive  bool
	IsAdmin   bool
	IsGm      bool
	IsGuest   bool
	IsPlayer  bool
	IsService bool
	IsSysop   bool
	IsUser    bool
}

func (q *Queries) ReadUserRoles(ctx context.Context, userID int64) (ReadUserRolesRow, error) {
	row := q.db.QueryRowContext(ctx, readUserRoles, userID)
	var i ReadUserRolesRow
	err := row.Scan(
		&i.IsActive,
		&i.IsAdmin,
		&i.IsGm,
		&i.IsGuest,
		&i.IsPlayer,
		&i.IsService,
		&i.IsSysop,
		&i.IsUser,
	)
	return i, err
}

const readUserSecret = `-- name: ReadUserSecret :one
SELECT hashed_password
FROM users
WHERE user_id = ?1
`

// ReadUserSecret returns the password for a user.
// The password is stored as a bcrypt hash.
func (q *Queries) ReadUserSecret(ctx context.Context, userID int64) (string, error) {
	row := q.db.QueryRowContext(ctx, readUserSecret, userID)
	var hashed_password string
	err := row.Scan(&hashed_password)
	return hashed_password, err
}

const readUsers = `-- name: ReadUsers :many
SELECT user_id,
       handle,
       username,
       email,
       email_opt_in,
       timezone,
       is_active,
       is_admin,
       is_gm,
       is_guest,
       is_player,
       is_service,
       is_sysop,
       is_user,
       created_at,
       updated_at
FROM users
ORDER BY username
`

type ReadUsersRow struct {
	UserID     int64
	Handle     string
	Username   string
	Email      string
	EmailOptIn bool
	Timezone   string
	IsActive   bool
	IsAdmin    bool
	IsGm       bool
	IsGuest    bool
	IsPlayer   bool
	IsService  bool
	IsSysop    bool
	IsUser     bool
	CreatedAt  int64
	UpdatedAt  int64
}

func (q *Queries) ReadUsers(ctx context.Context) ([]ReadUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, readUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadUsersRow
	for rows.Next() {
		var i ReadUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Handle,
			&i.Username,
			&i.Email,
			&i.EmailOptIn,
			&i.Timezone,
			&i.IsActive,
			&i.IsAdmin,
			&i.IsGm,
			&i.IsGuest,
			&i.IsPlayer,
			&i.IsService,
			&i.IsSysop,
			&i.IsUser,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readUsersVisibleToActor = `-- name: ReadUsersVisibleToActor :many
SELECT user_id,
       handle,
       username,
       email,
       email_opt_in,
       timezone,
       is_active,
       is_admin,
       is_gm,
       is_guest,
       is_player,
       is_service,
       is_sysop,
       is_user,
       created_at,
       updated_at
FROM users
WHERE ?1 = 1
  AND ?2 = 1
  AND ?3 = 1
ORDER BY username
`

type ReadUsersVisibleToActorParams struct {
	ActorID  interface{}
	PageSize interface{}
	PageNum  interface{}
}

type ReadUsersVisibleToActorRow struct {
	UserID     int64
	Handle     string
	Username   string
	Email      string
	EmailOptIn bool
	Timezone   string
	IsActive   bool
	IsAdmin    bool
	IsGm       bool
	IsGuest    bool
	IsPlayer   bool
	IsService  bool
	IsSysop    bool
	IsUser     bool
	CreatedAt  int64
	UpdatedAt  int64
}

func (q *Queries) ReadUsersVisibleToActor(ctx context.Context, arg ReadUsersVisibleToActorParams) ([]ReadUsersVisibleToActorRow, error) {
	rows, err := q.db.QueryContext(ctx, readUsersVisibleToActor, arg.ActorID, arg.PageSize, arg.PageNum)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadUsersVisibleToActorRow
	for rows.Next() {
		var i ReadUsersVisibleToActorRow
		if err := rows.Scan(
			&i.UserID,
			&i.Handle,
			&i.Username,
			&i.Email,
			&i.EmailOptIn,
			&i.Timezone,
			&i.IsActive,
			&i.IsAdmin,
			&i.IsGm,
			&i.IsGuest,
			&i.IsPlayer,
			&i.IsService,
			&i.IsSysop,
			&i.IsUser,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmailByUserId = `-- name: UpdateEmailByUserId :exec
UPDATE users
SET email        = LOWER(?1),
    email_opt_in = ?2,
    updated_at   = ?3
WHERE user_id = ?4
`

type UpdateEmailByUserIdParams struct {
	Email      string
	EmailOptIn bool
	UpdatedAt  int64
	UserID     int64
}

func (q *Queries) UpdateEmailByUserId(ctx context.Context, arg UpdateEmailByUserIdParams) error {
	_, err := q.db.ExecContext(ctx, updateEmailByUserId,
		arg.Email,
		arg.EmailOptIn,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}

const updateHandleByUserId = `-- name: UpdateHandleByUserId :exec
UPDATE users
SET handle     = LOWER(?1),
    updated_at = ?2
WHERE user_id = ?3
`

type UpdateHandleByUserIdParams struct {
	Handle    string
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateHandleByUserId(ctx context.Context, arg UpdateHandleByUserIdParams) error {
	_, err := q.db.ExecContext(ctx, updateHandleByUserId, arg.Handle, arg.UpdatedAt, arg.UserID)
	return err
}

const updateTimezoneByUserId = `-- name: UpdateTimezoneByUserId :exec
UPDATE users
SET timezone   = ?1,
    updated_at = ?2
WHERE user_id = ?3
`

type UpdateTimezoneByUserIdParams struct {
	Timezone  string
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateTimezoneByUserId(ctx context.Context, arg UpdateTimezoneByUserIdParams) error {
	_, err := q.db.ExecContext(ctx, updateTimezoneByUserId, arg.Timezone, arg.UpdatedAt, arg.UserID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET handle       = ?1,
    username     = ?2,
    email        = ?3,
    email_opt_in = ?4,
    timezone     = ?5,
    is_active    = ?6,
    is_admin     = ?7,
    is_gm        = ?8,
    is_guest     = ?9,
    is_player    = ?10,
    is_service   = ?11,
    is_sysop     = ?12,
    is_user      = ?13,
    updated_at   = ?14
WHERE ?15 = ?15
`

type UpdateUserParams struct {
	Handle     string
	Username   string
	Email      string
	EmailOptIn bool
	Timezone   string
	IsActive   bool
	IsAdmin    bool
	IsGm       bool
	IsGuest    bool
	IsPlayer   bool
	IsService  bool
	IsSysop    bool
	IsUser     bool
	UpdatedAt  int64
	UserID     interface{}
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Handle,
		arg.Username,
		arg.Email,
		arg.EmailOptIn,
		arg.Timezone,
		arg.IsActive,
		arg.IsAdmin,
		arg.IsGm,
		arg.IsGuest,
		arg.IsPlayer,
		arg.IsService,
		arg.IsSysop,
		arg.IsUser,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}

const updateUserActiveRole = `-- name: UpdateUserActiveRole :exec
UPDATE users
SET is_active  = ?1,
    updated_at = ?2
WHERE user_id = ?3
  AND is_sysop = 0
`

type UpdateUserActiveRoleParams struct {
	HasRole   bool
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUserActiveRole(ctx context.Context, arg UpdateUserActiveRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserActiveRole, arg.HasRole, arg.UpdatedAt, arg.UserID)
	return err
}

const updateUserAdminRole = `-- name: UpdateUserAdminRole :exec
UPDATE users
SET is_admin   = ?1,
    updated_at = ?2
WHERE user_id = ?3
  AND is_sysop = 0
`

type UpdateUserAdminRoleParams struct {
	HasRole   bool
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUserAdminRole(ctx context.Context, arg UpdateUserAdminRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAdminRole, arg.HasRole, arg.UpdatedAt, arg.UserID)
	return err
}

const updateUserGMRole = `-- name: UpdateUserGMRole :exec
UPDATE users
SET is_gm      = ?1,
    updated_at = ?2
WHERE user_id = ?3
  AND is_sysop = 0
`

type UpdateUserGMRoleParams struct {
	HasRole   bool
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUserGMRole(ctx context.Context, arg UpdateUserGMRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserGMRole, arg.HasRole, arg.UpdatedAt, arg.UserID)
	return err
}

const updateUserGuestRole = `-- name: UpdateUserGuestRole :exec
UPDATE users
SET is_active  = 1,
    is_admin   = 0,
    is_gm      = 0,
    is_guest   = ?1,
    is_player  = 0,
    is_user    = 0,
    updated_at = ?2
WHERE user_id = ?3
  AND is_sysop = 0
`

type UpdateUserGuestRoleParams struct {
	HasRole   bool
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUserGuestRole(ctx context.Context, arg UpdateUserGuestRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserGuestRole, arg.HasRole, arg.UpdatedAt, arg.UserID)
	return err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET last_login = ?1,
    updated_at = ?2
WHERE user_id = ?3
`

type UpdateUserLastLoginParams struct {
	LastLogin int64
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUserLastLogin(ctx context.Context, arg UpdateUserLastLoginParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLastLogin, arg.LastLogin, arg.UpdatedAt, arg.UserID)
	return err
}

const updateUserPlayerRole = `-- name: UpdateUserPlayerRole :exec
UPDATE users
SET is_player  = ?1,
    updated_at = ?2
WHERE user_id = ?3
  AND is_sysop = 0
`

type UpdateUserPlayerRoleParams struct {
	HasRole   bool
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUserPlayerRole(ctx context.Context, arg UpdateUserPlayerRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPlayerRole, arg.HasRole, arg.UpdatedAt, arg.UserID)
	return err
}

const updateUserRoles = `-- name: UpdateUserRoles :exec
UPDATE users
SET is_active  = ?1,
    is_admin   = ?2,
    is_gm      = ?3,
    is_guest   = ?4,
    is_player  = ?5,
    is_user    = ?6,
    updated_at = ?7
WHERE user_id = ?8
  AND is_service = 0
  AND is_sysop = 0
`

type UpdateUserRolesParams struct {
	IsActive  bool
	IsAdmin   bool
	IsGm      bool
	IsGuest   bool
	IsPlayer  bool
	IsUser    bool
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUserRoles(ctx context.Context, arg UpdateUserRolesParams) error {
	_, err := q.db.ExecContext(ctx, updateUserRoles,
		arg.IsActive,
		arg.IsAdmin,
		arg.IsGm,
		arg.IsGuest,
		arg.IsPlayer,
		arg.IsUser,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}

const updateUserSecret = `-- name: UpdateUserSecret :exec
UPDATE users
SET hashed_password    = ?1,
    plaintext_password = ?2,
    updated_at         = ?3
WHERE user_id = ?4
`

type UpdateUserSecretParams struct {
	HashedPassword    string
	PlaintextPassword string
	UpdatedAt         int64
	UserID            int64
}

// UpdateUserSecret stores the secret for the user.
// The password is stored as a bcrypt hash.
func (q *Queries) UpdateUserSecret(ctx context.Context, arg UpdateUserSecretParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSecret,
		arg.HashedPassword,
		arg.PlaintextPassword,
		arg.UpdatedAt,
		arg.UserID,
	)
	return err
}

const updateUserUserRole = `-- name: UpdateUserUserRole :exec
UPDATE users
SET is_user    = ?1,
    updated_at = ?2
WHERE user_id = ?3
  AND is_sysop = 0
`

type UpdateUserUserRoleParams struct {
	HasRole   bool
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUserUserRole(ctx context.Context, arg UpdateUserUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserUserRole, arg.HasRole, arg.UpdatedAt, arg.UserID)
	return err
}

const updateUsernameByUserId = `-- name: UpdateUsernameByUserId :exec
UPDATE users
SET username   = ?1,
    updated_at = ?2
WHERE user_id = ?3
`

type UpdateUsernameByUserIdParams struct {
	Username  string
	UpdatedAt int64
	UserID    int64
}

func (q *Queries) UpdateUsernameByUserId(ctx context.Context, arg UpdateUsernameByUserIdParams) error {
	_, err := q.db.ExecContext(ctx, updateUsernameByUserId, arg.Username, arg.UpdatedAt, arg.UserID)
	return err
}
