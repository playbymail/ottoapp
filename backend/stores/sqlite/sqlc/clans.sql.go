// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clans.sql

package sqlc

import (
	"context"
)

const getClan = `-- name: GetClan :one
SELECT game_id,
       user_id,
       clan_id,
       clan,
       setup_turn_id,
       is_active
FROM clans
WHERE clan_id = ?1
`

type GetClanRow struct {
	GameID      int64
	UserID      int64
	ClanID      int64
	Clan        int64
	SetupTurnID int64
	IsActive    bool
}

func (q *Queries) GetClan(ctx context.Context, clanID int64) (GetClanRow, error) {
	row := q.db.QueryRowContext(ctx, getClan, clanID)
	var i GetClanRow
	err := row.Scan(
		&i.GameID,
		&i.UserID,
		&i.ClanID,
		&i.Clan,
		&i.SetupTurnID,
		&i.IsActive,
	)
	return i, err
}

const getClanByGameClanNo = `-- name: GetClanByGameClanNo :one
SELECT game_id,
       user_id,
       clan_id,
       clan,
       setup_turn_id,
       is_active
FROM clans
WHERE game_id = ?1
  AND clan = ?2
`

type GetClanByGameClanNoParams struct {
	GameID int64
	ClanNo int64
}

type GetClanByGameClanNoRow struct {
	GameID      int64
	UserID      int64
	ClanID      int64
	Clan        int64
	SetupTurnID int64
	IsActive    bool
}

func (q *Queries) GetClanByGameClanNo(ctx context.Context, arg GetClanByGameClanNoParams) (GetClanByGameClanNoRow, error) {
	row := q.db.QueryRowContext(ctx, getClanByGameClanNo, arg.GameID, arg.ClanNo)
	var i GetClanByGameClanNoRow
	err := row.Scan(
		&i.GameID,
		&i.UserID,
		&i.ClanID,
		&i.Clan,
		&i.SetupTurnID,
		&i.IsActive,
	)
	return i, err
}

const getClanByGameUser = `-- name: GetClanByGameUser :one
SELECT game_id,
       user_id,
       clan_id,
       clan,
       setup_turn_id,
       is_active
FROM clans
WHERE game_id = ?1
  AND user_id = ?2
`

type GetClanByGameUserParams struct {
	GameID int64
	UserID int64
}

type GetClanByGameUserRow struct {
	GameID      int64
	UserID      int64
	ClanID      int64
	Clan        int64
	SetupTurnID int64
	IsActive    bool
}

func (q *Queries) GetClanByGameUser(ctx context.Context, arg GetClanByGameUserParams) (GetClanByGameUserRow, error) {
	row := q.db.QueryRowContext(ctx, getClanByGameUser, arg.GameID, arg.UserID)
	var i GetClanByGameUserRow
	err := row.Scan(
		&i.GameID,
		&i.UserID,
		&i.ClanID,
		&i.Clan,
		&i.SetupTurnID,
		&i.IsActive,
	)
	return i, err
}

const readClansByGame = `-- name: ReadClansByGame :many
SELECT game_id, user_id, clan_id, clan
FROM clans
WHERE game_id = ?1
  AND is_active = 1
ORDER BY clans.clan
`

type ReadClansByGameRow struct {
	GameID int64
	UserID int64
	ClanID int64
	Clan   int64
}

func (q *Queries) ReadClansByGame(ctx context.Context, gameID int64) ([]ReadClansByGameRow, error) {
	rows, err := q.db.QueryContext(ctx, readClansByGame, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadClansByGameRow
	for rows.Next() {
		var i ReadClansByGameRow
		if err := rows.Scan(
			&i.GameID,
			&i.UserID,
			&i.ClanID,
			&i.Clan,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeClan = `-- name: RemoveClan :exec
DELETE
FROM clans
WHERE clan_id = ?1
`

func (q *Queries) RemoveClan(ctx context.Context, clanID int64) error {
	_, err := q.db.ExecContext(ctx, removeClan, clanID)
	return err
}

const upsertGameUserClan = `-- name: UpsertGameUserClan :one
INSERT INTO clans (game_id, user_id, clan, setup_turn_id, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
ON CONFLICT (user_id, game_id) DO UPDATE SET clan          = excluded.clan,
                                             setup_turn_id = excluded.setup_turn_id,
                                             updated_at    = excluded.updated_at
RETURNING clan_id
`

type UpsertGameUserClanParams struct {
	GameID      int64
	UserID      int64
	Clan        int64
	SetupTurnID int64
	CreatedAt   int64
	UpdatedAt   int64
}

// UpsertGameUserClan has two business rules
//
//	user can have at most one clan per game.
//	clan number can be used by at most one user per game.
//
// The upsert key is "user_id, game_id," preventing a user
// from claiming multiple clans in a game. If a user tries
// claiming an existing clan in a game, it will fail, not
// silently clobber another user's.
func (q *Queries) UpsertGameUserClan(ctx context.Context, arg UpsertGameUserClanParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertGameUserClan,
		arg.GameID,
		arg.UserID,
		arg.Clan,
		arg.SetupTurnID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var clan_id int64
	err := row.Scan(&clan_id)
	return clan_id, err
}
