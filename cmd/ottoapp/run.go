// Copyright (c) 2025 Michael D Henderson. All rights reserved.

package main

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"time"

	"github.com/playbymail/ottoapp/backend/parsers"
	"github.com/playbymail/ottoapp/backend/services/email"
	"github.com/playbymail/ottoapp/backend/services/games"
	"github.com/spf13/cobra"
)

func cmdRun() *cobra.Command {
	var cmd = &cobra.Command{
		Use:   "run",
		Short: "Run utility commands",
	}

	cmd.AddCommand(cmdRunGenMake())
	cmd.AddCommand(cmdRunParse())
	cmd.AddCommand(cmdRunWelcomeEmail())

	return cmd
}

func cmdRunGenMake() *cobra.Command {
	rootDir := filepath.Join("data", "tn3.1")
	outputPath := filepath.Join(rootDir, "maps.mk")
	addFlags := func(cmd *cobra.Command) error {
		cmd.Flags().StringVar(&rootDir, "root", rootDir, "root directory for data")
		cmd.Flags().StringVar(&outputPath, "output", outputPath, "output makefile path")
		return nil
	}

	cmd := &cobra.Command{
		Use:   "genmake",
		Short: "Generate a Makefile for map generation",
		Long:  `Scans the data directory for turn reports and generates a Makefile to build maps.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			// Normalize root path
			rootDir = filepath.Clean(rootDir)

			// Regex to match clan directories (e.g., 0500)
			clanDirRe := regexp.MustCompile(`^0\d{3}$`)
			// Regex to match report files (e.g., 0899-12.0500.report.docx or .txt)
			reportFileRe := regexp.MustCompile(`^(\d{4}-\d{2})\.(\d{4})\.report\.(docx|txt)$`)

			type TurnData struct {
				ID string
				// Set of file clan IDs found for this turn (e.g., "0987", "0134")
				FileClans map[string]bool
			}

			type ClanData struct {
				ID    string
				Turns map[string]*TurnData
			}
			clans := make(map[string]*ClanData)

			// Walk the directory structure
			entries, err := os.ReadDir(rootDir)
			if err != nil {
				return fmt.Errorf("reading root dir: %w", err)
			}

			for _, entry := range entries {
				if !entry.IsDir() {
					continue
				}
				clanID := entry.Name()
				if !clanDirRe.MatchString(clanID) {
					continue
				}

				// Check inside the clan directory for input data
				inputDir := filepath.Join(rootDir, clanID, "data", "input")
				files, err := os.ReadDir(inputDir)
				if os.IsNotExist(err) {
					continue
				}
				if err != nil {
					return fmt.Errorf("reading input dir for clan %s: %w", clanID, err)
				}

				for _, file := range files {
					if file.IsDir() {
						continue
					}
					matches := reportFileRe.FindStringSubmatch(file.Name())
					if matches == nil {
						continue
					}
					turnID := matches[1]
					fileClanID := matches[2]

					// We accept files from any clan inside this directory now.
					// The map will be generated for the folder's clanID (owner),
					// but it depends on all these files.

					if _, ok := clans[clanID]; !ok {
						clans[clanID] = &ClanData{
							ID:    clanID,
							Turns: make(map[string]*TurnData),
						}
					}

					if _, ok := clans[clanID].Turns[turnID]; !ok {
						clans[clanID].Turns[turnID] = &TurnData{
							ID:        turnID,
							FileClans: make(map[string]bool),
						}
					}
					clans[clanID].Turns[turnID].FileClans[fileClanID] = true
				}
			}

			// Sort clans
			var clanIDs []string
			for id := range clans {
				clanIDs = append(clanIDs, id)
			}
			sort.Strings(clanIDs)

			// Open output file
			f, err := os.Create(outputPath)
			if err != nil {
				return fmt.Errorf("creating output file: %w", err)
			}
			defer f.Close()

			// Write Makefile header
			fmt.Fprintf(f, "# Generated by ottoapp run genmake\n")
			fmt.Fprintf(f, "# Root: %s\n\n", rootDir)

			// Define tool paths - using relative paths from the makefile execution context
			fmt.Fprintf(f, "OTTOAPP := %s/bin/ottoapp\n", rootDir)
			fmt.Fprintf(f, "OTTOMAP := %s/bin/ottomap\n", rootDir)
			fmt.Fprintf(f, "\n")

			fmt.Fprintf(f, ".PHONY: all maps\n\n")
			fmt.Fprintf(f, "all: maps\n\n")

			// Collect all map targets for the 'maps' phony target
			var allMaps []string

			// Buffer specific rules to write them after the 'all' target
			var specificRules strings.Builder

			// Pattern rule for extracting text reports
			fmt.Fprintf(f, "# Pattern rule to extract text report from docx\n")
			fmt.Fprintf(f, "%%.report.txt: %%.report.docx\n")
			fmt.Fprintf(f, "\t@echo \"Extracting $@...\"\n")
			fmt.Fprintf(f, "\t@$(OTTOAPP) report extract $< --output $@\n\n")

			// Collect validation errors
			var validationErrors []string

			for _, clanID := range clanIDs {
				data := clans[clanID]

				// Validate directories exist
				basePath := filepath.Join(rootDir, clanID, "data")
				outputDir := filepath.Join(basePath, "output")
				logsDir := filepath.Join(basePath, "logs")

				if _, err := os.Stat(outputDir); os.IsNotExist(err) {
					validationErrors = append(validationErrors, fmt.Sprintf("clan %s: output directory missing: %s", clanID, outputDir))
				}
				if _, err := os.Stat(logsDir); os.IsNotExist(err) {
					validationErrors = append(validationErrors, fmt.Sprintf("clan %s: logs directory missing: %s", clanID, logsDir))
				}

				// Sort turns
				var turns []string
				for turn := range data.Turns {
					turns = append(turns, turn)
				}
				sort.Strings(turns)

				fmt.Fprintf(&specificRules, "# Clan %s\n", clanID)

				var previousReports []string

				for _, turnID := range turns {
					turnData := data.Turns[turnID]

					// Define paths relative to CWD (where make is run)
					inputPath := filepath.Join(basePath, "input")
					outputPath := filepath.Join(basePath, "output")

					// Sort file clans for deterministic output
					var fileClans []string
					for fc := range turnData.FileClans {
						fileClans = append(fileClans, fc)
					}
					sort.Strings(fileClans)

					// Add dependencies for this turn
					for _, fc := range fileClans {
						txtFile := filepath.Join(inputPath, fmt.Sprintf("%s.%s.report.txt", turnID, fc))
						previousReports = append(previousReports, txtFile)
					}

					mapFile := filepath.Join(outputPath, fmt.Sprintf("%s.%s.wxx", turnID, clanID))
					allMaps = append(allMaps, mapFile)

					// Map generation rule
					fmt.Fprintf(&specificRules, "%s: %s\n", mapFile, strings.Join(previousReports, " "))
					fmt.Fprintf(&specificRules, "\t@echo \"Rendering %s...\"\n", mapFile)

					logPath := filepath.Join(basePath, "logs", fmt.Sprintf("%s.%s.log", turnID, clanID))
					errPath := filepath.Join(basePath, "logs", fmt.Sprintf("%s.%s.err", turnID, clanID))

					fmt.Fprintf(&specificRules, "\t@$(OTTOMAP) render --data %s --clan-id %s --max-turn %s --show-grid-coords --save-with-turn-id 2> %s || (mv %s %s && exit 1)\n\n",
						filepath.Join(rootDir, clanID, "data"),
						clanID,
						turnID,
						logPath,
						logPath,
						errPath,
					)
				}
			}

			if len(validationErrors) > 0 {
				for _, errMsg := range validationErrors {
					fmt.Fprintln(os.Stderr, errMsg)
				}
				// Clean up partial output file
				f.Close()
				os.Remove(outputPath)
				return fmt.Errorf("validation failed with %d errors", len(validationErrors))
			}

			fmt.Fprintf(f, "maps: %s\n\n", strings.Join(allMaps, " "))
			fmt.Fprintf(f, "%s", specificRules.String())

			fmt.Printf("Generated Makefile at %s with %d map targets\n", outputPath, len(allMaps))

			return nil
		},
	}

	if err := addFlags(cmd); err != nil {
		log.Fatalf("%s: %v\n", cmd.Use, err)
	}

	return cmd
}

func cmdRunParse() *cobra.Command {
	var cmd = &cobra.Command{
		Use:   "parse",
		Short: "Run parser commands",
	}

	cmd.AddCommand(cmdRunParseReportFile())

	return cmd
}

func cmdRunParseReportFile() *cobra.Command {
	var outputPath string
	addFlags := func(cmd *cobra.Command) error {
		cmd.Flags().StringVar(&outputPath, "output", outputPath, "path to save parsed report to")
		return nil
	}

	var cmd = &cobra.Command{
		Use:   "report <turn-report-file-name>",
		Short: "Parse a turn report file",
		Args:  cobra.ExactArgs(1), // require path to turn report file
		RunE: func(cmd *cobra.Command, args []string) error {
			startedAt := time.Now()
			report := args[0]
			if strings.ToLower(filepath.Ext(report)) != ".docx" {
				return fmt.Errorf("turn report file must be .docx")
			}

			var docx *parsers.Docx
			if input, err := os.ReadFile(report); err != nil {
				log.Fatal(err)
			} else if docx, err = parsers.ParseDocx(bytes.NewReader(input)); err != nil {
				log.Fatal(err)
			}

			if outputPath == "" {
				fmt.Println(string(docx.Text))
				return nil
			}
			if err := os.WriteFile(outputPath, docx.Text, 0o644); err != nil {
				log.Fatalf("error: %v\n", err)
			}
			log.Printf("%s: created in %v\n", outputPath, time.Since(startedAt))
			return nil
		},
	}

	if err := addFlags(cmd); err != nil {
		log.Fatal(err)
	}

	return cmd
}

func cmdRunWelcomeEmail() *cobra.Command {
	var gameDataPath string
	var gameID string
	addFlags := func(cmd *cobra.Command) error {
		cmd.Flags().StringVar(&gameDataPath, "game-data", gameDataPath, "path to game data (required)")
		if err := cmd.MarkFlagRequired("game-data"); err != nil {
			return err
		}
		cmd.Flags().StringVar(&gameID, "game", gameID, "Game ID (required)")
		if err := cmd.MarkFlagRequired("game"); err != nil {
			return err
		}
		return nil
	}

	cmd := &cobra.Command{
		Use:          "welcome-email",
		Short:        "Send a welcome email to all players in a game",
		SilenceUsage: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			if gameDataPath == "" {
				return fmt.Errorf("--game-data is required")
			}
			if gameID == "" {
				return fmt.Errorf("--game is required")
			}

			// load the game data from the json file (should be in the database?)
			data, err := games.LoadGameData(gameDataPath)
			if err != nil {
				return err
			} else if data.Config.Mailgun == nil {
				log.Printf("error: missing mailgun config in game data\n")
				return nil
			}

			ctx := context.Background()

			emailSvc, err := email.NewMailgun(data.Config.Mailgun.ApiBase, data.Config.Mailgun.Domain, data.Config.Mailgun.ApiKey, data.Config.Mailgun.From, data.Config.Mailgun.ReplyTo)
			if err != nil {
				log.Fatal(err)
			}

			// fetch the game details
			var gd *games.ImportGame
			for _, g := range data.Games {
				if g.Id == gameID {
					gd = g
					break
				}
			}
			if gd == nil {
				log.Printf("error: unknown game %q\n", gameID)
				return nil
			}

			// fetch the players in the game
			var players []*games.ImportPlayer
			for _, p := range data.Players {
				if !(p.Config != nil && p.Config.EmailOptIn == true) {
					continue
				}
				for _, g := range p.Games {
					if g.Id == gd.Id {
						players = append(players, p)
						break
					}
				}
			}

			log.Printf("%s: sending welcome email to %d players\n", gd.Description, len(players))
			if len(players) == 0 {
				return nil
			}

			for _, p := range players {
				if p.Email == "" {
					continue
				}
				var pgd *games.ImportPlayerGame
				for _, g := range p.Games {
					if g.Id == gd.Id {
						pgd = g
						break
					}
				}
				if pgd == nil { // should never happen
					continue
				}

				// On registration:
				if err := emailSvc.SendWelcome(ctx, p.Email, p.Username, gd.Description, pgd.Clan, p.Password); err != nil {
					log.Printf("%s: %04d: %s: email %v\n", gd.Description, pgd.Clan, p.Email, err)
					continue
				}

				log.Printf("%s: %04d: %s: email sent\n", gd.Description, pgd.Clan, p.Email)
			}

			log.Println("Done.")
			return nil
		},
	}

	if err := addFlags(cmd); err != nil {
		log.Fatalf("%s: %v\n", cmd.Use, err)
	}

	return cmd
}
