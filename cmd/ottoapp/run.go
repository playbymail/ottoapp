// Copyright (c) 2025 Michael D Henderson. All rights reserved.

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/spf13/cobra"
)

var cmdRunGenMake = &cobra.Command{
	Use:   "genmake",
	Short: "Generate a Makefile for map generation",
	Long:  `Scans the data directory for turn reports and generates a Makefile to build maps.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		rootDir, err := cmd.Flags().GetString("root")
		if err != nil {
			return err
		}
		outputPath, err := cmd.Flags().GetString("output")
		if err != nil {
			return err
		}

		// Normalize root path
		rootDir = filepath.Clean(rootDir)

		// Regex to match clan directories (e.g., 0500)
		clanDirRe := regexp.MustCompile(`^0\d{3}$`)
		// Regex to match report files (e.g., 0899-12.0500.report.docx or .txt)
		reportFileRe := regexp.MustCompile(`^(\d{4}-\d{2})\.(\d{4})\.report\.(docx|txt)$`)

		type TurnData struct {
			ID string
			// Set of file clan IDs found for this turn (e.g., "0987", "0134")
			FileClans map[string]bool
		}

		type ClanData struct {
			ID    string
			Turns map[string]*TurnData
		}
		clans := make(map[string]*ClanData)

		// Walk the directory structure
		entries, err := os.ReadDir(rootDir)
		if err != nil {
			return fmt.Errorf("reading root dir: %w", err)
		}

		for _, entry := range entries {
			if !entry.IsDir() {
				continue
			}
			clanID := entry.Name()
			if !clanDirRe.MatchString(clanID) {
				continue
			}

			// Check inside the clan directory for input data
			inputDir := filepath.Join(rootDir, clanID, "data", "input")
			files, err := os.ReadDir(inputDir)
			if os.IsNotExist(err) {
				continue
			}
			if err != nil {
				return fmt.Errorf("reading input dir for clan %s: %w", clanID, err)
			}

			for _, file := range files {
				if file.IsDir() {
					continue
				}
				matches := reportFileRe.FindStringSubmatch(file.Name())
				if matches == nil {
					continue
				}
				turnID := matches[1]
				fileClanID := matches[2]

				// We accept files from any clan inside this directory now.
				// The map will be generated for the folder's clanID (owner),
				// but it depends on all these files.

				if _, ok := clans[clanID]; !ok {
					clans[clanID] = &ClanData{
						ID:    clanID,
						Turns: make(map[string]*TurnData),
					}
				}

				if _, ok := clans[clanID].Turns[turnID]; !ok {
					clans[clanID].Turns[turnID] = &TurnData{
						ID:        turnID,
						FileClans: make(map[string]bool),
					}
				}
				clans[clanID].Turns[turnID].FileClans[fileClanID] = true
			}
		}

		// Sort clans
		var clanIDs []string
		for id := range clans {
			clanIDs = append(clanIDs, id)
		}
		sort.Strings(clanIDs)

		// Open output file
		f, err := os.Create(outputPath)
		if err != nil {
			return fmt.Errorf("creating output file: %w", err)
		}
		defer f.Close()

		// Write Makefile header
		fmt.Fprintf(f, "# Generated by ottoapp run genmake\n")
		fmt.Fprintf(f, "# Root: %s\n\n", rootDir)

		// Define tool paths - using relative paths from the makefile execution context
		fmt.Fprintf(f, "OTTOAPP := %s/bin/ottoapp\n", rootDir)
		fmt.Fprintf(f, "OTTOMAP := %s/bin/ottomap\n", rootDir)
		fmt.Fprintf(f, "\n")

		fmt.Fprintf(f, ".PHONY: all maps\n\n")
		fmt.Fprintf(f, "all: maps\n\n")

		// Collect all map targets for the 'maps' phony target
		var allMaps []string

		// Buffer specific rules to write them after the 'all' target
		var specificRules strings.Builder

		// Pattern rule for extracting text reports
		fmt.Fprintf(f, "# Pattern rule to extract text report from docx\n")
		fmt.Fprintf(f, "%%.report.txt: %%.report.docx\n")
		fmt.Fprintf(f, "\t@echo \"Extracting $@...\"\n")
		fmt.Fprintf(f, "\t@$(OTTOAPP) report extract $< --output $@\n\n")

		// Collect validation errors
		var validationErrors []string

		for _, clanID := range clanIDs {
			data := clans[clanID]

			// Validate directories exist
			basePath := filepath.Join(rootDir, clanID, "data")
			outputDir := filepath.Join(basePath, "output")
			logsDir := filepath.Join(basePath, "logs")

			if _, err := os.Stat(outputDir); os.IsNotExist(err) {
				validationErrors = append(validationErrors, fmt.Sprintf("clan %s: output directory missing: %s", clanID, outputDir))
			}
			if _, err := os.Stat(logsDir); os.IsNotExist(err) {
				validationErrors = append(validationErrors, fmt.Sprintf("clan %s: logs directory missing: %s", clanID, logsDir))
			}

			// Sort turns
			var turns []string
			for turn := range data.Turns {
				turns = append(turns, turn)
			}
			sort.Strings(turns)

			fmt.Fprintf(&specificRules, "# Clan %s\n", clanID)

			var previousReports []string

			for _, turnID := range turns {
				turnData := data.Turns[turnID]

				// Define paths relative to CWD (where make is run)
				inputPath := filepath.Join(basePath, "input")
				outputPath := filepath.Join(basePath, "output")

				// Sort file clans for deterministic output
				var fileClans []string
				for fc := range turnData.FileClans {
					fileClans = append(fileClans, fc)
				}
				sort.Strings(fileClans)

				// Add dependencies for this turn
				for _, fc := range fileClans {
					txtFile := filepath.Join(inputPath, fmt.Sprintf("%s.%s.report.txt", turnID, fc))
					previousReports = append(previousReports, txtFile)
				}

				mapFile := filepath.Join(outputPath, fmt.Sprintf("%s.%s.wxx", turnID, clanID))
				allMaps = append(allMaps, mapFile)

				// Map generation rule
				fmt.Fprintf(&specificRules, "%s: %s\n", mapFile, strings.Join(previousReports, " "))
				fmt.Fprintf(&specificRules, "\t@echo \"Rendering %s...\"\n", mapFile)

				logPath := filepath.Join(basePath, "logs", fmt.Sprintf("%s.%s.log", turnID, clanID))
				errPath := filepath.Join(basePath, "logs", fmt.Sprintf("%s.%s.err", turnID, clanID))

				fmt.Fprintf(&specificRules, "\t@$(OTTOMAP) render --data %s --clan-id %s --max-turn %s --show-grid-coords --save-with-turn-id 2> %s || (mv %s %s && exit 1)\n\n",
					filepath.Join(rootDir, clanID, "data"),
					clanID,
					turnID,
					logPath,
					logPath,
					errPath,
				)
			}
		}

		if len(validationErrors) > 0 {
			for _, errMsg := range validationErrors {
				fmt.Fprintln(os.Stderr, errMsg)
			}
			// Clean up partial output file
			f.Close()
			os.Remove(outputPath)
			return fmt.Errorf("validation failed with %d errors", len(validationErrors))
		}

		fmt.Fprintf(f, "maps: %s\n\n", strings.Join(allMaps, " "))
		fmt.Fprintf(f, "%s", specificRules.String())

		fmt.Printf("Generated Makefile at %s with %d map targets\n", outputPath, len(allMaps))

		return nil
	},
}
