// Copyright (c) 2025 Michael D Henderson. All rights reserved.

package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"time"

	"github.com/playbymail/ottoapp/backend/parsers"
	"github.com/playbymail/ottoapp/backend/parsers/reports"
	"github.com/playbymail/ottoapp/backend/parsers/reports/scrubbers"
	"github.com/playbymail/ottoapp/backend/services/email"
	"github.com/playbymail/ottoapp/backend/services/games"
	"github.com/spf13/cobra"
)

func cmdRun() *cobra.Command {
	var cmd = &cobra.Command{
		Use:   "run",
		Short: "Run utility commands",
	}

	cmd.AddCommand(cmdRunGenMake())
	cmd.AddCommand(cmdRunParse())
	cmd.AddCommand(cmdRunWelcomeEmail())

	return cmd
}

func cmdRunGenMake() *cobra.Command {
	makefileName := "maps.mk"
	oldBehavior := false
	addFlags := func(cmd *cobra.Command) error {
		cmd.Flags().StringVar(&makefileName, "output", makefileName, "name of makefile to create")
		cmd.Flags().BoolVar(&oldBehavior, "old-behavior", oldBehavior, "enable old behavior")
		return nil
	}

	cmd := &cobra.Command{
		Use:   "genmake",
		Short: "Generate a Makefile for map generation",
		Long:  `Scans the data directory for turn reports and generates a Makefile to build maps.`,
		Args:  cobra.ExactArgs(1), // require path to TN3.1 root
		RunE: func(cmd *cobra.Command, args []string) error {
			// Normalize root path
			rootDir, err := filepath.Abs(args[0])
			if err != nil {
				return errors.Join(fmt.Errorf("invalid path"), err)
			} else if sb, err := os.Stat(rootDir); err != nil {
				return errors.Join(fmt.Errorf("invalid path"), err)
			} else if !sb.IsDir() {
				return fmt.Errorf("%s: not a directory", rootDir)
			}
			log.Printf("%s: root\n", rootDir)

			if filepath.Base(makefileName) != makefileName {
				return fmt.Errorf("%s: not a filename", makefileName)
			} else if filepath.Ext(makefileName) != ".mk" {
				makefileName += ".mk"
			}
			makefileName = filepath.Join(rootDir, makefileName)
			log.Printf("%s: make file\n", makefileName)

			if !oldBehavior {
				return nil
			}

			// Regex to match clan directories (e.g., 0500)
			clanDirRe := regexp.MustCompile(`^0\d{3}$`)
			// Regex to match report files (e.g., 0899-12.0500.report.docx or .txt)
			reportFileRe := regexp.MustCompile(`^(\d{4}-\d{2})\.(\d{4})\.report\.(docx|txt)$`)

			type TurnData struct {
				ID string
				// Set of file clan IDs found for this turn (e.g., "0987", "0134")
				FileClans map[string]bool
			}

			type ClanData struct {
				ID    string
				Turns map[string]*TurnData
			}
			clans := make(map[string]*ClanData)

			// Walk the directory structure
			entries, err := os.ReadDir(rootDir)
			if err != nil {
				return fmt.Errorf("reading root dir: %w", err)
			}

			for _, entry := range entries {
				if !entry.IsDir() {
					continue
				}
				clanID := entry.Name()
				if !clanDirRe.MatchString(clanID) {
					continue
				}

				// Check inside the clan directory for input data
				inputDir := filepath.Join(rootDir, clanID, "data", "input")
				files, err := os.ReadDir(inputDir)
				if os.IsNotExist(err) {
					continue
				}
				if err != nil {
					return fmt.Errorf("reading input dir for clan %s: %w", clanID, err)
				}

				for _, file := range files {
					if file.IsDir() {
						continue
					}
					matches := reportFileRe.FindStringSubmatch(file.Name())
					if matches == nil {
						continue
					}
					turnID := matches[1]
					fileClanID := matches[2]

					// We accept files from any clan inside this directory now.
					// The map will be generated for the folder's clanID (owner),
					// but it depends on all these files.

					if _, ok := clans[clanID]; !ok {
						clans[clanID] = &ClanData{
							ID:    clanID,
							Turns: make(map[string]*TurnData),
						}
					}

					if _, ok := clans[clanID].Turns[turnID]; !ok {
						clans[clanID].Turns[turnID] = &TurnData{
							ID:        turnID,
							FileClans: make(map[string]bool),
						}
					}
					clans[clanID].Turns[turnID].FileClans[fileClanID] = true
				}
			}

			// Sort clans
			var clanIDs []string
			for id := range clans {
				clanIDs = append(clanIDs, id)
			}
			sort.Strings(clanIDs)

			// Open output file
			f, err := os.Create(makefileName)
			if err != nil {
				return fmt.Errorf("creating output file: %w", err)
			}
			defer f.Close()

			// Write Makefile header
			fmt.Fprintf(f, "# Generated by ottoapp run genmake\n")
			fmt.Fprintf(f, "# Root: %s\n\n", rootDir)

			// Define tool paths - using relative paths from the makefile execution context
			fmt.Fprintf(f, "OTTOAPP := %s/bin/ottoapp\n", rootDir)
			fmt.Fprintf(f, "OTTOMAP := %s/bin/ottomap\n", rootDir)
			fmt.Fprintf(f, "\n")

			fmt.Fprintf(f, ".PHONY: all maps\n\n")
			fmt.Fprintf(f, "all: maps\n\n")

			// Collect all map targets for the 'maps' phony target
			var allMaps []string

			// Buffer specific rules to write them after the 'all' target
			var specificRules strings.Builder

			// Pattern rule for extracting text reports
			fmt.Fprintf(f, "# Pattern rule to extract text report from docx\n")
			fmt.Fprintf(f, "%%.report.txt: %%.report.docx\n")
			fmt.Fprintf(f, "\t@echo \"Extracting $@...\"\n")
			fmt.Fprintf(f, "\t@$(OTTOAPP) report extract $< --output $@\n\n")

			// Collect validation errors
			var validationErrors []string

			for _, clanID := range clanIDs {
				data := clans[clanID]

				// Validate directories exist
				basePath := filepath.Join(rootDir, clanID, "data")
				outputDir := filepath.Join(basePath, "output")
				logsDir := filepath.Join(basePath, "logs")

				if _, err := os.Stat(outputDir); os.IsNotExist(err) {
					validationErrors = append(validationErrors, fmt.Sprintf("clan %s: output directory missing: %s", clanID, outputDir))
				}
				if _, err := os.Stat(logsDir); os.IsNotExist(err) {
					validationErrors = append(validationErrors, fmt.Sprintf("clan %s: logs directory missing: %s", clanID, logsDir))
				}

				// Sort turns
				var turns []string
				for turn := range data.Turns {
					turns = append(turns, turn)
				}
				sort.Strings(turns)

				fmt.Fprintf(&specificRules, "# Clan %s\n", clanID)

				var previousReports []string

				for _, turnID := range turns {
					turnData := data.Turns[turnID]

					// Define paths relative to CWD (where make is run)
					inputPath := filepath.Join(basePath, "input")
					outputPath := filepath.Join(basePath, "output")

					// Sort file clans for deterministic output
					var fileClans []string
					for fc := range turnData.FileClans {
						fileClans = append(fileClans, fc)
					}
					sort.Strings(fileClans)

					// Add dependencies for this turn
					for _, fc := range fileClans {
						txtFile := filepath.Join(inputPath, fmt.Sprintf("%s.%s.report.txt", turnID, fc))
						previousReports = append(previousReports, txtFile)
					}

					mapFile := filepath.Join(outputPath, fmt.Sprintf("%s.%s.wxx", turnID, clanID))
					allMaps = append(allMaps, mapFile)

					// Map generation rule
					fmt.Fprintf(&specificRules, "%s: %s\n", mapFile, strings.Join(previousReports, " "))
					fmt.Fprintf(&specificRules, "\t@echo \"Rendering %s...\"\n", mapFile)

					logPath := filepath.Join(basePath, "logs", fmt.Sprintf("%s.%s.log", turnID, clanID))
					errPath := filepath.Join(basePath, "logs", fmt.Sprintf("%s.%s.err", turnID, clanID))

					fmt.Fprintf(&specificRules, "\t@$(OTTOMAP) render --data %s --clan-id %s --max-turn %s --show-grid-coords --save-with-turn-id 2> %s || (mv %s %s && exit 1)\n\n",
						filepath.Join(rootDir, clanID, "data"),
						clanID,
						turnID,
						logPath,
						logPath,
						errPath,
					)
				}
			}

			if len(validationErrors) > 0 {
				for _, errMsg := range validationErrors {
					fmt.Fprintln(os.Stderr, errMsg)
				}
				// Clean up partial output file
				f.Close()
				os.Remove(makefileName)
				return fmt.Errorf("validation failed with %d errors", len(validationErrors))
			}

			fmt.Fprintf(f, "maps: %s\n\n", strings.Join(allMaps, " "))
			fmt.Fprintf(f, "%s", specificRules.String())

			fmt.Printf("Generated Makefile at %s with %d map targets\n", makefileName, len(allMaps))

			return nil
		},
	}

	if err := addFlags(cmd); err != nil {
		log.Fatalf("%s: %v\n", cmd.Use, err)
	}

	return cmd
}

func cmdRunParse() *cobra.Command {
	var cmd = &cobra.Command{
		Use:   "parse",
		Short: "Run parser commands",
	}

	cmd.AddCommand(cmdRunParseReportFile())
	cmd.AddCommand(cmdRunParseTurnReport())

	return cmd
}

func cmdRunParseReportFile() *cobra.Command {
	var outputPath string
	trimLeading := true
	trimTrailing := true
	addFlags := func(cmd *cobra.Command) error {
		cmd.Flags().BoolVar(&trimLeading, "trim-leading", trimLeading, "trim leading spaces")
		cmd.Flags().BoolVar(&trimTrailing, "trim-trailing", trimTrailing, "trim trailing spaces")
		cmd.Flags().StringVar(&outputPath, "output", outputPath, "path to save parsed report to")
		return nil
	}

	var cmd = &cobra.Command{
		Use:   "report <turn-report-file-name>",
		Short: "Parse a turn report file",
		Args:  cobra.ExactArgs(1), // require path to turn report file
		RunE: func(cmd *cobra.Command, args []string) error {
			startedAt := time.Now()
			report := args[0]
			if strings.ToLower(filepath.Ext(report)) != ".docx" {
				return fmt.Errorf("turn report file must be .docx")
			}

			var docx *parsers.Docx
			if input, err := os.ReadFile(report); err != nil {
				log.Fatal(err)
			} else if docx, err = parsers.ParseDocx(bytes.NewReader(input), trimLeading, trimTrailing); err != nil {
				log.Fatal(err)
			}

			if outputPath == "" {
				fmt.Println(string(docx.Text))
				return nil
			}
			if err := os.WriteFile(outputPath, docx.Text, 0o644); err != nil {
				log.Fatalf("error: %v\n", err)
			}
			log.Printf("%s: created in %v\n", outputPath, time.Since(startedAt))
			return nil
		},
	}

	if err := addFlags(cmd); err != nil {
		log.Fatal(err)
	}

	return cmd
}

func cmdRunParseTurnReport() *cobra.Command {
	rawExtractFile := ""
	scrubbedFile := ""
	showJson := false
	showStats := false
	showTiming := false
	addFlags := func(cmd *cobra.Command) error {
		cmd.Flags().StringVar(&rawExtractFile, "raw-extract", rawExtractFile, "path to save raw extract to")
		cmd.Flags().StringVar(&scrubbedFile, "scrubbed-extract", scrubbedFile, "path to save scrubbed extract to")
		cmd.Flags().BoolVar(&showJson, "show-json", showJson, "show json after extract")
		cmd.Flags().BoolVar(&showStats, "show-stats", showStats, "show stats after extract")
		cmd.Flags().BoolVar(&showTiming, "show-timing", showStats, "show timing after extract")
		return nil
	}

	var cmd = &cobra.Command{
		Use:          "turn-report <turn-report-file-name>",
		Short:        "Parse a turn report file",
		SilenceUsage: true,
		Args:         cobra.ExactArgs(1), // require path to turn report file
		RunE: func(cmd *cobra.Command, args []string) error {
			startedAt := time.Now()

			var docx *parsers.Docx
			docxFileName := args[0]
			if data, err := os.ReadFile(docxFileName); err != nil {
				return err
			} else if docx, err = parsers.ParseDocx(bytes.NewReader(data), false, false); err != nil {
				return err
			}
			if showTiming {
				log.Printf("%s: %d bytes\n", args[0], len(docx.Text))
			}
			if rawExtractFile != "" {
				err := os.WriteFile(rawExtractFile, docx.Text, 0o644)
				if err != nil {
					return err
				}
				if showTiming {
					log.Printf("%s: wrote raw extract\n", rawExtractFile)
				}
			}

			lines := scrubbers.Scrub(bytes.Split(docx.Text, []byte{'\n'}))
			if scrubbedFile != "" {
				output := bytes.Join(lines, []byte{'\n'})
				if len(output) == 0 {
					output = []byte{'\n'}
				} else if output[len(output)-1] != '\n' {
					output = append(output, '\n')
				}
				err := os.WriteFile(scrubbedFile, output, 0o644)
				if err != nil {
					return err
				}
				if showTiming {
					log.Printf("%s: wrote scrubbed extract\n", scrubbedFile)
				}
			}

			stats := reports.Stats{}
			rpt, err := reports.Parse(filepath.Base(docxFileName), bytes.Join(lines, []byte{'\n'}), reports.Statistics(&stats, "no match"))
			if err != nil {
				return err
			}
			if showJson {
				b, err := json.MarshalIndent(rpt, "", "  ")
				if err != nil {
					return err
				}
				log.Printf("rpt: %s\n", string(b))
			}
			if showStats {
				b, err := json.MarshalIndent(stats.ChoiceAltCnt, "", "  ")
				if err != nil {
					return err
				}
				log.Printf("rpt: %s\n", string(b))
			}

			if showTiming {
				log.Printf("parse: turn-report: completed in %v\n", time.Since(startedAt))
			}

			return nil
		},
	}

	if err := addFlags(cmd); err != nil {
		log.Fatal(err)
	}

	return cmd
}

func cmdRunWelcomeEmail() *cobra.Command {
	var gameDataPath string
	var gameID string
	addFlags := func(cmd *cobra.Command) error {
		cmd.Flags().StringVar(&gameDataPath, "game-data", gameDataPath, "path to game data (required)")
		if err := cmd.MarkFlagRequired("game-data"); err != nil {
			return err
		}
		cmd.Flags().StringVar(&gameID, "game", gameID, "Game ID (required)")
		if err := cmd.MarkFlagRequired("game"); err != nil {
			return err
		}
		return nil
	}

	cmd := &cobra.Command{
		Use:          "welcome-email",
		Short:        "Send a welcome email to all players in a game",
		SilenceUsage: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			if gameDataPath == "" {
				return fmt.Errorf("--game-data is required")
			}
			if gameID == "" {
				return fmt.Errorf("--game is required")
			}

			// load the game data from the json file (should be in the database?)
			data, err := games.LoadGameData(gameDataPath)
			if err != nil {
				return err
			} else if data.Config.Mailgun == nil {
				log.Printf("error: missing mailgun config in game data\n")
				return nil
			}

			ctx := context.Background()

			emailSvc, err := email.NewMailgun(data.Config.Mailgun.ApiBase, data.Config.Mailgun.Domain, data.Config.Mailgun.ApiKey, data.Config.Mailgun.From, data.Config.Mailgun.ReplyTo)
			if err != nil {
				log.Fatal(err)
			}

			// fetch the game details
			var gd *games.ImportGame
			for _, g := range data.Games {
				if g.Id == gameID {
					gd = g
					break
				}
			}
			if gd == nil {
				log.Printf("error: unknown game %q\n", gameID)
				return nil
			}

			// fetch the players in the game
			var players []*games.ImportPlayer
			for _, p := range data.Players {
				if !(p.Config != nil && p.Config.EmailOptIn == true && p.Config.SendWelcomeMail == true) {
					continue
				}
				for _, g := range p.Games {
					if g.Id == gd.Id {
						players = append(players, p)
						break
					}
				}
			}

			log.Printf("%s: sending welcome email to %d players\n", gd.Description, len(players))
			if len(players) == 0 {
				return nil
			}

			for _, p := range players {
				if p.Email == "" {
					continue
				}
				var pgd *games.ImportPlayerGame
				for _, g := range p.Games {
					if g.Id == gd.Id {
						pgd = g
						break
					}
				}
				if pgd == nil { // should never happen
					continue
				}

				// On registration:
				if err := emailSvc.SendWelcome(ctx, p.Email, p.Username, gd.Description, pgd.Clan, p.Password); err != nil {
					log.Printf("%s: %04d: %s: email %v\n", gd.Description, pgd.Clan, p.Email, err)
					continue
				}

				log.Printf("%s: %04d: %s: email sent\n", gd.Description, pgd.Clan, p.Email)
			}

			log.Println("Done.")
			return nil
		},
	}

	if err := addFlags(cmd); err != nil {
		log.Fatalf("%s: %v\n", cmd.Use, err)
	}

	return cmd
}
