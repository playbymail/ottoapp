// Copyright (c) 2025 Michael D Henderson. All rights reserved.

// godel generates Ember Data models from Go structs with jsonapi tags
package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

func main() {
	var (
		inputFile  string
		structName string
		outputFile string
	)

	flag.StringVar(&inputFile, "input", "", "Go source file containing the struct")
	flag.StringVar(&structName, "struct", "", "Name of the struct to generate from")
	flag.StringVar(&outputFile, "output", "", "Output file path for Ember model")
	flag.Parse()

	if inputFile == "" || structName == "" || outputFile == "" {
		flag.Usage()
		os.Exit(1)
	}

	// Parse the Go source file
	model, err := parseStruct(inputFile, structName)
	if err != nil {
		log.Fatalf("error parsing struct: %v", err)
	}

	// Generate the Ember model
	if err := generateEmberModel(model, outputFile); err != nil {
		log.Fatalf("error generating model: %v", err)
	}

	fmt.Printf("Generated Ember model: %s\n", outputFile)
}

// Field represents a model field
type Field struct {
	Name      string // JavaScript field name
	EmberType string // Ember attr type ('string', 'date', etc.)
	IsArray   bool
	IsObject  bool
}

// Model represents the parsed struct
type Model struct {
	Name   string  // Model name (e.g., "user")
	Fields []Field // Model fields
}

// parseStruct parses a Go struct and extracts jsonapi fields
func parseStruct(filename, structName string) (*Model, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parsing file: %w", err)
	}

	var model *Model

	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Name.Name != structName {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// Found the struct, extract model name from jsonapi primary tag
		modelName := ""
		fields := []Field{}

		for _, field := range structType.Fields.List {
			if field.Tag == nil {
				continue
			}

			tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
			jsonapiTag := tag.Get("jsonapi")
			if jsonapiTag == "" {
				continue
			}

			parts := strings.Split(jsonapiTag, ",")
			if len(parts) < 2 {
				continue
			}

			tagType := parts[0]
			tagName := parts[1]

			// Handle primary key
			if tagType == "primary" {
				modelName = tagName
				continue
			}

			// Handle attributes
			if tagType == "attr" && len(field.Names) > 0 {
				goType := typeToString(field.Type)
				emberType, isArray, isObject := mapGoTypeToEmber(goType)

				// Convert dasherized names to camelCase for JavaScript
				emberFieldName := dasherizedToCamelCase(tagName)

				fields = append(fields, Field{
					Name:      emberFieldName,
					EmberType: emberType,
					IsArray:   isArray,
					IsObject:  isObject,
				})
			}
		}

		if modelName != "" {
			// Use exact model name from jsonapi tag
			model = &Model{
				Name:   modelName,
				Fields: fields,
			}
		}

		return false
	})

	if model == nil {
		return nil, fmt.Errorf("struct %s not found or has no jsonapi tags", structName)
	}

	return model, nil
}

// typeToString converts an ast.Expr type to a string representation
func typeToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", typeToString(t.X), t.Sel.Name)
	case *ast.ArrayType:
		return "[]" + typeToString(t.Elt)
	case *ast.MapType:
		return fmt.Sprintf("map[%s]%s", typeToString(t.Key), typeToString(t.Value))
	default:
		return "unknown"
	}
}

// mapGoTypeToEmber maps Go types to Ember Data attr types
func mapGoTypeToEmber(goType string) (emberType string, isArray bool, isObject bool) {
	switch {
	case goType == "string":
		return "string", false, false
	case goType == "time.Time":
		return "date", false, false
	case goType == "bool":
		return "boolean", false, false
	case goType == "int" || goType == "int64" || goType == "int32" || goType == "float64" || goType == "float32":
		return "number", false, false
	case strings.HasPrefix(goType, "[]"):
		return "", true, false
	case strings.HasPrefix(goType, "map["):
		return "", false, true
	default:
		return "", false, false
	}
}

// generateEmberModel generates the Ember Data model file
func generateEmberModel(model *Model, outputFile string) error {
	tmpl := template.Must(template.New("ember-model").Parse(`// Generated by godel - DO NOT EDIT
// Source: {{.SourceFile}}

import Model, { attr } from '@ember-data/model';

export default class {{.ModelClassName}} extends Model {
{{- range .Fields}}
  @attr({{.AttrType}}) {{.Name}};
{{- end}}
}
`))

	// Get source file name
	sourceFile := "unknown"
	if input := flag.Lookup("input"); input != nil {
		sourceFile = filepath.Base(input.Value.String())
	}

	// Prepare template data
	data := struct {
		SourceFile     string
		ModelClassName string
		Fields         []struct {
			Name     string
			AttrType string
		}
	}{
		SourceFile:     sourceFile,
		ModelClassName: capitalizeFirst(model.Name) + "Model",
		Fields:         make([]struct{ Name, AttrType string }, len(model.Fields)),
	}

	for i, field := range model.Fields {
		attrType := ""
		if field.EmberType != "" {
			attrType = fmt.Sprintf("'%s'", field.EmberType)
		}
		data.Fields[i] = struct{ Name, AttrType string }{
			Name:     field.Name,
			AttrType: attrType,
		}
	}

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	// Create output file
	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("creating output file: %w", err)
	}
	defer f.Close()

	// Execute template
	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	return nil
}

// capitalizeFirst capitalizes the first letter of a string
func capitalizeFirst(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// dasherizedToCamelCase converts dasherized-name to camelCaseName
func dasherizedToCamelCase(s string) string {
	if !strings.Contains(s, "-") {
		return s
	}
	parts := strings.Split(s, "-")
	for i := 1; i < len(parts); i++ {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}
